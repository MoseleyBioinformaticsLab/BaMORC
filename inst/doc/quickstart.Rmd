---
title: "Getting started with BaMORC"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Getting started with httr}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, echo = FALSE}
library(knitr)
opts_chunk$set(tidy.opts=list(width.cutoff=60),tidy=TRUE)
knitr::opts_chunk$set(comment = "#>", collapse = TRUE)
```

# BaMORC quickstart guide

The goal of this document is to get you up and running with BaMORC as quickly as possible. BaMORC is designed as Bayesian Model Optimized Reference Correction (BaMORC) Method for Assigned and Unassigned Protein NMR Spectra. For a detailed explanation of the algorithm please refer to "[Automatic 13C chemical shift reference correction for unassigned protein NMR spectra](https://doi.org/10.1007/s10858-018-0202-5)".

There are two important parts to BaMORC: the `bamorc()`, reference correction function for assigned 13C protein  NMR spectra, and the `unassigned_bamorc()`, reference correction function for unassigned 13C protein NMR spectra. In the first section, you'll learn about the basics of running both of the functions. In the second section, you will dive into the basics of input data process, and in third section, you'll learn a little more on functions of the behind-the-scenes of the BaMORC algorithm.

## BaMORC basics

To make a correction, first load BaMORC, then call `bamorc()` or `unassigned_bamorc()` with correct arguments:

```{r}
library(BaMORC)
```

### For assigned protein NMR spectra:

Here we will using the built-in data to demonstrate the arguments that will be passed in the `bamorc()`.

```{r, cache=TRUE}
## Arguments:
sequence = paste(RefDB_data$carbonDat[[1]]$AA, collapse = "")
secondary_structure = paste(RefDB_data$carbonDat[[1]]$SS, collapse = "")
chemical_shifts_input = RefDB_data$carbonDat[[1]][, c(4,5)]
from= -5
to = 5

## Running bamorc() function:
bamorc(sequence = sequence, secondary_structure = secondary_structure, 
       chemical_shifts_input = chemical_shifts_input, from = -5, to = 5)
```

* `sequence`: <string> the sequence of protein of interest with single-letter convention.
* `secondary_structure`: <string> the secondary structure information of the protein with with single-letter convention.
* `chemical_shifts_input`: <data frame n by 2> the carbon 13 chemical shift of the protein.
* `from` and `to`: <numeric> the upper- and lower-bound of optimization range. Value assigned to `from` must be lower than `to`.

The length of the `sequence` and `secondary_structure` should be the same, if not pleasue assign `secondary_structure = NULL`, however, the peaklist groups number could be more or less than the length of the sequence. Since commonly the output of the spectra should have a little deviate from the sequence information.

Printing an argument object gives you some useful information: the actual format, the size, the object type, and if it's a string. 

### For unassigned protein NMR spectra:

Next we will using the built-in data to demonstrate the arguments that will be passed in the `unassigned_bamorc()`. The output will be slight different each time runs due to the randomness of the optimization.

```{r, cache=TRUE}
## Arguments:enerate a temperary sample NMR spectra file and later will be 
## removed.
sequence = "RPAFCLEPPYAGPGKARIIRYFYNAAAGAAQAFVYGGVRAKRNNFASAADALAACAAA"
sample_data_generator(input_type = "ssc_sample")
file_path = "./bpti_HNcoCACB.txt" # temperary sample file path.

## Running unassigned_bamorc() function:
unassigned_bamorc(peakList_file_loc = file_path, sequence = sequence, 
                  secondary_structure = NULL, from = -5, to = 5)

## Delete the temperary sample file.
unlink("./bpti_HNcoCACB.txt")
```


# The data processing:

The data passed in both above functions should be pre-processed. Luckly, we provided a varity of helper functions. I'll show you how to process the data as following.

## The sample generating functions:

There are three file reading functions within the BaMORC package: `read_raw_file()`, `read_NMRSTAR_file()`, and `read_DB_File()`. Even though, these functions should handle a wide range of the input files, however, a good file formation are highly recommanded. You can check the sample file using the `sample_data_generator()` with following code:

* Delimiter of white space:
    ```{r}
    ## Arguments:enerate a temperary sample NMR spectra file and later will be 
    ## removed.
    input_type = "ws" 
    sample_data_generator(input_type = input_type)
    
    ## Running reading function
    head(read_raw_file(file_path = "sample_input_ws.txt", delim = "ws"))
    unlink("sample_input_ws.txt")
    ```

* Delimiter of comma:
    ```{r}
    ## Arguments:enerate a temperary sample NMR spectra file and later will be 
    ## removed.
    input_type = "csv" 
    sample_data_generator(input_type = input_type)
    
    ## Running reading function
    head(read_raw_file(file_path = "sample_input.csv", delim = "comma"))
    unlink("sample_input.csv")
    ```
    
* Delimiter of semicolon:
    ```{r}
    ## Arguments:enerate a temperary sample NMR spectra file and later will be 
    ## removed.
    input_type = "sc" 
    sample_data_generator(input_type = input_type)
    
    ## Running reading function
    head(read_raw_file(file_path = "sample_input_sc.txt", delim = "semicolon"))
    unlink("sample_input_sc.txt")
    ```

## The reading functions will return sequence and chemical shifts:
* `read_raw_file()`: parses user-provided file in customed format as show above examples. 

* `read_NMRSTAR_file()`: parses user-provided file in BMRB Star 2/3 format.
```{r}
## Download a BMRB file
library(BMRBr)
bmrb_download(4020, output_dir = "./")

## Read in BMRB file and procec
file_path = "bmr4020.str"
head(read_NMRSTAR_file(file_path = file_path))

## Delete downloaded BMRB file
unlink("./bmr4020.str")
```

* `read_DB_File()`: parses file from BMRB by a given entry ID.
```{r}
id = 4022
output <- read_DB_File(id = id)
head(output[[1]])
head(output[[2]])
```

## Estimating econdary structure from sequence:

One important part of the optmization for referencing correction value is through providing the secondary structue information basin protein sequence. This is done through the [JPred](http://www.compbio.dundee.ac.uk/jpred/index.html) and jpredapi.

```{r}
protein_sequence <- "MQVWPIEGIKKFETLSYLPPLTVEDLLKQI"
secondary_structure <- jpred_fetcher(protein_sequence = protein_sequence)

secondary_structure
```

## Behind-the-scenes functions

The BaMORC algorithms relys minimize the difference betwee the actual relative cummulative frequence (RCF) of the protein sequence and estimated RCF from the chemical shifts information. The functions make the algorithm possible are showing below with examples, for detailed function descriptions, please see the reference.:

* `calculate_AA_Prob()`: returns the probability (density) for a certain type of amino acid based on a chi-squared statistics wtih 2 degrees of freedom.

```{r}
calculate_AA_Prob(chi_squared_stat = c(0.05, 0.1, 0.5), df = 2)
```


* `calculate_chi_squared_stat()`: given a pair of alpha and beta carbons chemical shifts, this function will return a list of caculated chisquare statistics based on the combination of amino acid typings and secondary structures. Here we illustrate with a pair of chemical shifts from alpha and beta carbon.
```{r}
calculate_chi_squared_stat(cacb_pair = c(54,45))
```


* `calculate_RCF()`: calculates the relative cummulative freqeucny of amino acid and secondary structure combination.
```{r}
## Arguments:
sequence = paste(RefDB_data$carbonDat[[1]]$AA, collapse = "")
secondary_structure = paste(RefDB_data$carbonDat[[1]]$SS, collapse = "")

## Function:
calculate_RCF(sequence = sequence, secondary_structure = secondary_structure)
```

* `calculate_MSE()`: calculates mean squared error for each correction value (step).
```{r}
## chemicalShifts and aaFreq are predefined sample variables for demo purpose 
## within the BaMORC Package.
calculate_MSE(step_ca = 1, step_cb = 1, dat_cacb = chemicalShifts[, c(3,4)], 
              aa_Freq = aaFreq)
```
